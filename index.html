<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Optimized viewport meta tag for iPhone/Safari -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Redhead Girl Catches Emojis</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* Center content vertically if it's less than screen height */
            min-height: 100vh; /* Ensure body takes at least full viewport height */
            margin: 0;
            background-color: #f0f0f0;
            overflow: hidden; /* Prevent scrollbars from game logic */
            text-align: center;
            touch-action: none; /* Prevents page scrolling on touch globally for this game */
        }

        #game-container {
            width: 90vw;
            max-width: 600px;
            height: 65vh; /* Slightly reduced height to give more room for controls */
            max-height: 700px; /* Adjusted max height */
            border: 3px solid #333;
            background-color: #ADD8E6; /* Light blue sky */
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
            cursor: grab;
        }
        #game-container:active {
            cursor: grabbing;
        }

        #girl {
            width: 60px;
            height: 60px;
            font-size: 50px;
            line-height: 60px;
            text-align: center;
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            user-select: none;
        }

        .emoji {
            font-size: 26px;
            position: absolute;
            user-select: none;
            transition: transform 0.2s ease-out, opacity 0.2s ease-out;
        }

        .emoji.caught {
            transform: scale(1.5) rotate(30deg);
            opacity: 0;
        }

        /* Wrapper for UI controls to handle safe area */
        #ui-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 90vw; /* Match game container width */
            max-width: 600px;
            padding-top: 10px; /* Space between game and status bar */
            /* Add base padding AND safe area inset for bottom */
            padding-bottom: calc(15px + env(safe-area-inset-bottom));
            box-sizing: border-box;
        }

        #status-bar {
            padding: 8px; /* Slightly reduced padding */
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            width: 100%; /* Take full width of #ui-controls */
            max-width: 350px; /* Max width for readability */
            box-sizing: border-box;
            margin-bottom: 10px; /* Space before buttons */
        }

        #start-button, #restart-button {
            padding: 12px 20px; /* Adjusted padding */
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            margin: 5px;
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight on iOS */
        }
        #restart-button {
            background-color: #f44336;
            display: none;
        }

        @media (max-width: 380px) { /* Adjusted breakpoint */
            h1 {
                font-size: 1.4em;
                margin-top: calc(10px + env(safe-area-inset-top)); /* Account for top notch/status bar */
                margin-bottom: 5px;
            }
            .emoji {
                font-size: 22px;
            }
            #girl {
                font-size: 40px;
                width: 50px;
                height: 50px;
                line-height: 50px;
            }
            #game-container {
                height: 60vh; /* Further reduce on very small screens */
            }
            #start-button, #restart-button {
                padding: 10px 15px;
                font-size: 14px;
            }
            #status-bar {
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body>

    <h1>Redhead Girl Catches Emojis</h1>

    <div id="game-container">
        <div id="girl">üë©‚Äçü¶∞</div>
        <!-- Emojis will be added here by JavaScript -->
    </div>

    <div id="ui-controls">
        <div id="status-bar">
            Emojis Caught: <span id="score">0</span> / 100
            <div id="message">Click "Start Game" to begin!</div>
        </div>
        <div> <!-- Wrapper for buttons -->
            <button id="start-button">Start Game</button>
            <button id="restart-button">Restart Game</button>
        </div>
    </div>

    <script>
        const gameContainer = document.getElementById('game-container');
        const girlElement = document.getElementById('girl');
        const scoreElement = document.getElementById('score');
        const messageElement = document.getElementById('message');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');

        const TOTAL_EMOJIS = 100;
        const EMOJI_TYPES = ['üòÇ', 'üíØ', '‚ù§Ô∏è', 'üò¢']; // Laughing, 100, heart, tear
        const EMOJI_FALL_SPEED_MIN = 0.7;
        const EMOJI_FALL_SPEED_MAX = 1.8;

        let emojisOnScreen = [];
        let score = 0;
        let gameLoopInterval = null;
        let spawnInterval = null;
        let emojisSpawned = 0;
        let missedEmojis = 0;

        let isDragging = false;

        function moveGirl(clientX) {
            const rect = gameContainer.getBoundingClientRect();
            let newLeft = clientX - rect.left - (girlElement.offsetWidth / 2);

            const minLeft = 0;
            const maxLeft = gameContainer.offsetWidth - girlElement.offsetWidth;
            newLeft = Math.max(minLeft, Math.min(newLeft, maxLeft));

            girlElement.style.left = newLeft + 'px';
        }

        // Mouse events for desktop
        gameContainer.addEventListener('mousedown', (e) => {
            if (!gameLoopInterval) return;
            isDragging = true;
            moveGirl(e.clientX);
            gameContainer.style.cursor = 'grabbing';
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging && gameLoopInterval) {
                moveGirl(e.clientX);
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                if (gameLoopInterval) gameContainer.style.cursor = 'grab';
                else gameContainer.style.cursor = 'default';
            }
        });

        // Touch events for mobile
        gameContainer.addEventListener('touchstart', (e) => {
            if (!gameLoopInterval) return;
            if (e.touches.length === 1) {
                // e.preventDefault(); // Usually not needed due to touch-action: none on body
                isDragging = true;
                moveGirl(e.touches[0].clientX);
            }
        }, { passive: true }); // passive: true if not calling preventDefault

        document.addEventListener('touchmove', (e) => {
            if (isDragging && gameLoopInterval && e.touches.length === 1) {
                // e.preventDefault();
                moveGirl(e.touches[0].clientX);
            }
        }, { passive: true });

        const endDrag = () => {
            if (isDragging) {
                isDragging = false;
                // No need to change cursor for touch
            }
        };
        document.addEventListener('touchend', endDrag);
        document.addEventListener('touchcancel', endDrag);


        function getCurrentEmojiPixelSize() {
            const tempEmoji = document.createElement('div');
            tempEmoji.classList.add('emoji');
            tempEmoji.style.visibility = 'hidden';
            tempEmoji.style.position = 'absolute';
            tempEmoji.textContent = 'üòÇ';
            document.body.appendChild(tempEmoji);
            const size = tempEmoji.offsetHeight;
            document.body.removeChild(tempEmoji);
            return size || 28;
        }

        function getRandomEmojiType() {
            return EMOJI_TYPES[Math.floor(Math.random() * EMOJI_TYPES.length)];
        }

        function createEmoji() {
            if (emojisSpawned >= TOTAL_EMOJIS && spawnInterval) {
                clearInterval(spawnInterval);
                spawnInterval = null;
                return;
            }
            if (emojisSpawned >= TOTAL_EMOJIS) return;


            const emoji = document.createElement('div');
            emoji.classList.add('emoji');
            emoji.textContent = getRandomEmojiType();

            const containerWidth = gameContainer.offsetWidth;
            const emojiApproximateSize = getCurrentEmojiPixelSize();

            emoji.style.left = Math.random() * (containerWidth - emojiApproximateSize) + 'px';
            emoji.style.top = -(emojiApproximateSize + 5) + 'px'; // Start a bit higher

            emoji.dataset.fallSpeed = EMOJI_FALL_SPEED_MIN + Math.random() * (EMOJI_FALL_SPEED_MAX - EMOJI_FALL_SPEED_MIN);
            emoji.dataset.driftX = (Math.random() - 0.5) * 0.4;

            gameContainer.appendChild(emoji);
            emojisOnScreen.push(emoji);
            emojisSpawned++;
        }

        function checkCollision(el1, el2) {
            const rect1 = el1.getBoundingClientRect();
            const rect2 = el2.getBoundingClientRect();

            return !(
                rect1.right < rect2.left ||
                rect1.left > rect2.right ||
                rect1.bottom < rect2.top ||
                rect1.top > rect2.bottom
            );
        }

        function gameLoop() {
            // const girlRect = girlElement.getBoundingClientRect(); // Recalculate if girl can move during this frame due to other factors

            for (let i = emojisOnScreen.length - 1; i >= 0; i--) {
                const emoji = emojisOnScreen[i];
                if (emoji.classList.contains('caught')) continue;

                let currentTop = parseFloat(emoji.style.top);
                let currentLeft = parseFloat(emoji.style.left);
                const fallSpeed = parseFloat(emoji.dataset.fallSpeed);
                const driftX = parseFloat(emoji.dataset.driftX);

                emoji.style.top = (currentTop + fallSpeed) + 'px';
                emoji.style.left = (currentLeft + driftX) + 'px';

                if (checkCollision(emoji, girlElement)) {
                    emoji.classList.add('caught');
                    score++;
                    scoreElement.textContent = score;

                    setTimeout(() => {
                        if (emoji.parentNode) {
                            emoji.parentNode.removeChild(emoji);
                        }
                    }, 200);
                    emojisOnScreen.splice(i, 1);

                    if (score === TOTAL_EMOJIS) {
                        endGame(true);
                        return;
                    }
                    continue;
                }

                if (currentTop > gameContainer.offsetHeight) {
                    if (emoji.parentNode) {
                        emoji.parentNode.removeChild(emoji);
                    }
                    emojisOnScreen.splice(i, 1);
                    missedEmojis++;

                    if (emojisSpawned >= TOTAL_EMOJIS && emojisOnScreen.length === 0) {
                         endGame(score === TOTAL_EMOJIS); // Should be false if some were missed
                         return;
                    }
                }

                if (currentLeft < 0 || currentLeft > gameContainer.offsetWidth - emoji.offsetWidth) {
                    emoji.dataset.driftX = -driftX;
                    emoji.style.left = Math.max(0, Math.min(currentLeft, gameContainer.offsetWidth - emoji.offsetWidth)) + 'px';
                }
            }

             if (emojisSpawned >= TOTAL_EMOJIS && emojisOnScreen.length === 0 && score < TOTAL_EMOJIS && gameLoopInterval) {
                 endGame(false);
            }
        }

        function startGame() {
            resetGame();
            messageElement.textContent = "Catch the emojis!";
            startButton.style.display = 'none';
            restartButton.style.display = 'inline-block';
            gameContainer.style.cursor = 'grab';

            const spawnRate = 300;
            spawnInterval = setInterval(createEmoji, spawnRate);
            if(gameLoopInterval) clearInterval(gameLoopInterval); // Ensure no duplicates
            gameLoopInterval = setInterval(gameLoop, 1000 / 60);
        }

        function endGame(won) {
            clearInterval(gameLoopInterval);
            gameLoopInterval = null; // Important to set to null
            if (spawnInterval) {
                clearInterval(spawnInterval);
                spawnInterval = null;
            }
            isDragging = false;
            gameContainer.style.cursor = 'default';


            if (won) {
                messageElement.textContent = "AWESOME! You caught all 100 emojis!";
                messageElement.style.color = 'green';
            } else {
                messageElement.textContent = `GAME OVER! Caught ${score}/${TOTAL_EMOJIS}. Missed: ${missedEmojis}.`;
                messageElement.style.color = 'red';
            }
            restartButton.style.display = 'inline-block';
            startButton.style.display = 'none';
        }

        function resetGame() {
            score = 0;
            emojisSpawned = 0;
            missedEmojis = 0;
            scoreElement.textContent = score;
            messageElement.textContent = 'Click "Start Game" to begin!';
            messageElement.style.color = 'black';
            gameContainer.style.cursor = 'default';


            emojisOnScreen.forEach(emoji => {
                if (emoji.parentNode) {
                    emoji.parentNode.removeChild(emoji);
                }
            });
            emojisOnScreen = [];

            if (gameLoopInterval) clearInterval(gameLoopInterval);
            if (spawnInterval) clearInterval(spawnInterval);
            gameLoopInterval = null;
            spawnInterval = null;

            girlElement.style.left = '50%';
            // transform translateX is already in CSS

            startButton.style.display = 'inline-block';
            restartButton.style.display = 'none';
        }

        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);

        resetGame();
    </script>

</body>
</html>