<!DOCTYPE html>
<html lang="ru"> <!-- Set language to Russian -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>–ü–æ–π–º–∞–π –≠–º–æ–¥–∑–∏</title> <!-- Russian Title -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #f0f4f8; /* Lighter, slightly blueish background */
            --text-color-dark: #2c3e50; /* Darker text for contrast */
            --text-color-light: #566573;
            --panel-bg: #ffffff;
            --border-color: #d6dbdf;
            --shadow-color-soft: rgba(44, 62, 80, 0.1);
            --shadow-color-medium: rgba(44, 62, 80, 0.15);
            --font-roboto: 'Roboto', sans-serif;

            --game-bg-start: #e0f2fe; /* Very light sky blue */
            --game-bg-end: #cce7ff;   /* Slightly deeper light sky blue */

            --button-start-bg: #27ae60; /* Emerald green */
            --button-start-hover-bg: #229954;
            --button-restart-bg: #e74c3c; /* Alizarin red */
            --button-restart-hover-bg: #c0392b;
            --button-text-color: #ffffff;
        }

        html {
            height: 100%;
        }
        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            min-height: 100svh;
            
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color-dark);
            font-family: var(--font-roboto);
            overflow: hidden;
            text-align: center;
            touch-action: none;

            padding-top: env(safe-area-inset-top, 0px);
            padding-left: env(safe-area-inset-left, 0px);
            padding-right: env(safe-area-inset-right, 0px);
            box-sizing: border-box;
        }

        #game-container {
            width: 90vw;
            max-width: 500px; /* Slightly smaller max-width for a sleeker look */
            height: 60vh; 
            max-height: 500px;
            background: linear-gradient(170deg, var(--game-bg-start), var(--game-bg-end));
            border: 1px solid var(--border-color);
            border-radius: 16px; /* More rounded corners */
            position: relative;
            overflow: hidden;
            box-shadow: 0 6px 12px var(--shadow-color-soft);
            cursor: grab;
            flex-shrink: 0;
            margin: 15px auto 0 auto; /* Top margin since title is gone, centered */
        }
        #game-container:active {
            cursor: grabbing;
        }

        #girl {
            width: 50px; /* Adjusted size for modern feel */
            height: 50px;
            font-size: 40px; /* Emoji size */
            line-height: 50px;
            text-align: center;
            position: absolute;
            bottom: 15px; /* Slightly more padding from bottom */
            left: 50%;
            transform: translateX(-50%);
            user-select: none;
        }

        .emoji {
            font-size: 24px; /* Slightly smaller falling emojis */
            position: absolute;
            user-select: none;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.2s ease-out;
        }

        .emoji.caught {
            transform: scale(1.6) rotate(20deg); /* More dynamic caught effect */
            opacity: 0;
        }

        #ui-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%; 
            box-sizing: border-box;
            margin-top: auto; 
            padding-top: 15px;
            padding-bottom: calc(15px + env(safe-area-inset-bottom, 0px));
        }

        #status-bar {
            background-color: var(--panel-bg);
            padding: 12px 18px;
            border-radius: 12px;
            width: 90vw;
            max-width: 380px;
            box-sizing: border-box;
            margin-bottom: 15px;
            box-shadow: 0 4px 8px var(--shadow-color-soft);
            font-size: 0.95em;
            color: var(--text-color-dark);
        }
        #status-bar #score-text {
            font-weight: 500;
        }
        #status-bar #message {
            font-size: 0.85em;
            color: var(--text-color-light);
            margin-top: 4px;
        }


        #buttons-wrapper {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
        }

        #start-button, #restart-button {
            padding: 12px 28px;
            font-size: 1em; /* Relative font size */
            font-weight: 500;
            cursor: pointer;
            color: var(--button-text-color);
            border: none;
            border-radius: 25px; /* Pill shape */
            margin: 8px;
            -webkit-tap-highlight-color: transparent;
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
            min-width: 160px; /* Ensure decent button width */
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }
        #start-button {
            background-color: var(--button-start-bg);
        }
        #restart-button {
            background-color: var(--button-restart-bg);
            display: none;
        }
        #start-button:hover, #restart-button:hover {
            filter: brightness(1.1);
        }
        #start-button:active, #restart-button:active {
            transform: scale(0.97);
            box-shadow: 0 1px 3px rgba(0,0,0,0.15);
        }


        @media (max-width: 400px) {
            #game-container {
                height: 55vh;
                max-height: 450px;
                border-radius: 12px;
                margin-top: 10px;
            }
            #girl {
                width: 45px; height: 45px; font-size: 35px; line-height: 45px; bottom: 10px;
            }
            .emoji { font-size: 20px; }

            #status-bar { padding: 10px 15px; max-width: 320px; font-size: 0.9em; }
            #status-bar #message { font-size: 0.8em; }

            #start-button, #restart-button {
                padding: 10px 20px;
                font-size: 0.9em;
                min-width: 140px;
            }
        }
    </style>
</head>
<body>
    <!-- Title removed -->
    <div id="game-container">
        <div id="girl">üë©‚Äçü¶∞</div>
    </div>

    <div id="ui-controls">
        <div id="status-bar">
            <span id="score-text">–ü–æ–π–º–∞–Ω–æ —ç–º–æ–¥–∑–∏: <span id="score">0</span> / 100</span>
            <div id="message">–ù–∞–∂–º–∏—Ç–µ "–ù–∞—á–∞—Ç—å –∏–≥—Ä—É", —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å!</div>
        </div>
        <div id="buttons-wrapper">
            <button id="start-button">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
            <button id="restart-button">–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
        </div>
    </div>

    <script>
        const gameContainer = document.getElementById('game-container');
        const girlElement = document.getElementById('girl');
        const scoreElement = document.getElementById('score');
        const messageElement = document.getElementById('message');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');

        const TOTAL_EMOJIS = 100;
        const EMOJI_TYPES = ['üòÇ', 'üíØ', '‚ù§Ô∏è', 'üò¢'];
        const EMOJI_FALL_SPEED_MIN = 0.8; // Slightly faster min speed for more engagement
        const EMOJI_FALL_SPEED_MAX = 2.0; // Slightly faster max speed

        let emojisOnScreen = [];
        let score = 0;
        let gameLoopInterval = null;
        let spawnInterval = null;
        let emojisSpawned = 0;
        let missedEmojis = 0;

        let isDragging = false;

        function moveGirl(clientX) {
            const rect = gameContainer.getBoundingClientRect();
            let newLeft = clientX - rect.left - (girlElement.offsetWidth / 2);

            const minLeft = 0;
            const maxLeft = gameContainer.offsetWidth - girlElement.offsetWidth;
            newLeft = Math.max(minLeft, Math.min(newLeft, maxLeft));

            girlElement.style.left = newLeft + 'px';
        }

        function canDrag() {
            return gameLoopInterval !== null; // Only allow dragging if game is active
        }

        gameContainer.addEventListener('mousedown', (e) => {
            if (!canDrag()) return;
            isDragging = true;
            moveGirl(e.clientX);
            gameContainer.style.cursor = 'grabbing';
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging && canDrag()) {
                moveGirl(e.clientX);
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                if (canDrag()) gameContainer.style.cursor = 'grab';
                else gameContainer.style.cursor = 'default';
            }
        });

        gameContainer.addEventListener('touchstart', (e) => {
            if (!canDrag()) return;
            if (e.touches.length === 1) {
                isDragging = true;
                moveGirl(e.touches[0].clientX);
            }
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
            if (isDragging && canDrag() && e.touches.length === 1) {
                moveGirl(e.touches[0].clientX);
            }
        }, { passive: true });

        const endDrag = () => {
            if (isDragging) {
                isDragging = false;
            }
        };
        document.addEventListener('touchend', endDrag);
        document.addEventListener('touchcancel', endDrag);


        function getCurrentEmojiPixelSize() {
            const tempEmoji = document.createElement('div');
            tempEmoji.classList.add('emoji');
            tempEmoji.style.visibility = 'hidden';
            tempEmoji.style.position = 'absolute';
            tempEmoji.textContent = 'üòÇ'; // Any emoji for sizing
            document.body.appendChild(tempEmoji);
            const size = tempEmoji.offsetHeight;
            document.body.removeChild(tempEmoji);
            // Fallback to CSS font-size (approx) if offsetHeight is 0 (e.g. display:none parent)
            return size || parseInt(window.getComputedStyle(tempEmoji).fontSize, 10) || 24;
        }


        function getRandomEmojiType() {
            return EMOJI_TYPES[Math.floor(Math.random() * EMOJI_TYPES.length)];
        }

        function createEmoji() {
            if (emojisSpawned >= TOTAL_EMOJIS && spawnInterval) {
                clearInterval(spawnInterval);
                spawnInterval = null;
                return;
            }
            if (emojisSpawned >= TOTAL_EMOJIS) return;


            const emoji = document.createElement('div');
            emoji.classList.add('emoji');
            emoji.textContent = getRandomEmojiType();

            const containerWidth = gameContainer.offsetWidth;
            const emojiApproximateSize = getCurrentEmojiPixelSize();

            emoji.style.left = Math.random() * (containerWidth - emojiApproximateSize) + 'px';
            emoji.style.top = -(emojiApproximateSize + 10) + 'px'; // Start a bit higher

            emoji.dataset.fallSpeed = EMOJI_FALL_SPEED_MIN + Math.random() * (EMOJI_FALL_SPEED_MAX - EMOJI_FALL_SPEED_MIN);
            emoji.dataset.driftX = (Math.random() - 0.5) * 0.5; // Increased horizontal drift a bit

            gameContainer.appendChild(emoji);
            emojisOnScreen.push(emoji);
            emojisSpawned++;
        }

        function checkCollision(el1, el2) {
            const rect1 = el1.getBoundingClientRect();
            const rect2 = el2.getBoundingClientRect();

            // A bit more forgiving collision (larger hit area for girl)
            const hitMargin = 5; // pixels
            return !(
                rect1.right < rect2.left - hitMargin ||
                rect1.left > rect2.right + hitMargin ||
                rect1.bottom < rect2.top - hitMargin ||
                rect1.top > rect2.bottom + hitMargin
            );
        }

        function gameLoop() {
            for (let i = emojisOnScreen.length - 1; i >= 0; i--) {
                const emoji = emojisOnScreen[i];
                if (!emoji || emoji.classList.contains('caught')) continue;

                let currentTop = parseFloat(emoji.style.top);
                let currentLeft = parseFloat(emoji.style.left);
                const fallSpeed = parseFloat(emoji.dataset.fallSpeed);
                const driftX = parseFloat(emoji.dataset.driftX);

                emoji.style.top = (currentTop + fallSpeed) + 'px';
                emoji.style.left = (currentLeft + driftX) + 'px';

                if (checkCollision(emoji, girlElement)) {
                    emoji.classList.add('caught');
                    score++;
                    scoreElement.textContent = score;

                    setTimeout(() => {
                        if (emoji.parentNode) {
                            emoji.parentNode.removeChild(emoji);
                        }
                    }, 200); // Match transition duration
                    emojisOnScreen.splice(i, 1);

                    if (score === TOTAL_EMOJIS) {
                        endGame(true);
                        return;
                    }
                    continue;
                }

                // Emoji missed (fell off bottom)
                if (currentTop > gameContainer.offsetHeight + emoji.offsetHeight / 2) { // Check when half of emoji is past
                    if (emoji.parentNode) {
                        emoji.parentNode.removeChild(emoji);
                    }
                    emojisOnScreen.splice(i, 1);
                    missedEmojis++;
                    checkEndOfGameCondition();
                    if (!gameLoopInterval) return; // Game ended by checkEndOfGameCondition
                }
                // Emoji missed (drifted off sides)
                else if (currentLeft < -emoji.offsetWidth || currentLeft > gameContainer.offsetWidth) {
                     if (emoji.parentNode) {
                        emoji.parentNode.removeChild(emoji);
                    }
                    emojisOnScreen.splice(i, 1);
                    missedEmojis++;
                    checkEndOfGameCondition();
                    if (!gameLoopInterval) return; // Game ended
                }
                // Bounce emoji if it hits horizontal edges but is still on screen
                else if (currentLeft < 0 || currentLeft > gameContainer.offsetWidth - emoji.offsetWidth) {
                    emoji.dataset.driftX = -driftX;
                    emoji.style.left = Math.max(0, Math.min(currentLeft, gameContainer.offsetWidth - emoji.offsetWidth)) + 'px';
                }
            }
            checkEndOfGameCondition(); // Check again at the end of the loop
        }

        function checkEndOfGameCondition() {
            if (gameLoopInterval && emojisSpawned >= TOTAL_EMOJIS && emojisOnScreen.length === 0) {
                 endGame(score === TOTAL_EMOJIS);
            }
        }


        function startGame() {
            resetGame();
            messageElement.textContent = "–õ–æ–≤–∏ —ç–º–æ–¥–∑–∏!";
            startButton.style.display = 'none';
            restartButton.style.display = 'inline-block';
            gameContainer.style.cursor = 'grab';

            const spawnRate = 300; // ms per emoji
            spawnInterval = setInterval(createEmoji, spawnRate);
            if(gameLoopInterval) clearInterval(gameLoopInterval);
            gameLoopInterval = setInterval(gameLoop, 1000 / 60); // ~60 FPS
        }

        function endGame(won) {
            if (!gameLoopInterval && !spawnInterval && startButton.style.display === 'none') return; // Already ended

            clearInterval(gameLoopInterval);
            gameLoopInterval = null;
            if (spawnInterval) {
                clearInterval(spawnInterval);
                spawnInterval = null;
            }
            isDragging = false;
            gameContainer.style.cursor = 'default';


            if (won) {
                messageElement.textContent = "–°–£–ü–ï–†! –¢—ã –ø–æ–π–º–∞–ª(–∞) –≤—Å–µ 100 —ç–º–æ–¥–∑–∏!";
                messageElement.style.color = 'var(--button-start-bg)';
            } else {
                messageElement.textContent = `–ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê! –ü–æ–π–º–∞–Ω–æ: ${score}/${TOTAL_EMOJIS}. –ü—Ä–æ–ø—É—â–µ–Ω–æ: ${missedEmojis}.`;
                messageElement.style.color = 'var(--button-restart-bg)';
            }
            restartButton.style.display = 'inline-block';
            startButton.style.display = 'none';
        }

        function resetGame() {
            score = 0;
            emojisSpawned = 0;
            missedEmojis = 0;
            scoreElement.textContent = score;
            messageElement.textContent = '–ù–∞–∂–º–∏—Ç–µ "–ù–∞—á–∞—Ç—å –∏–≥—Ä—É", —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å!';
            messageElement.style.color = 'var(--text-color-light)';
            gameContainer.style.cursor = 'default';


            // Clear existing emojis from DOM and array
            while(emojisOnScreen.length > 0) {
                const emoji = emojisOnScreen.pop();
                if (emoji.parentNode) {
                    emoji.parentNode.removeChild(emoji);
                }
            }
            // Also clear any remaining direct children of gameContainer that might be emojis
            Array.from(gameContainer.querySelectorAll('.emoji')).forEach(el => el.remove());


            if (gameLoopInterval) clearInterval(gameLoopInterval);
            if (spawnInterval) clearInterval(spawnInterval);
            gameLoopInterval = null;
            spawnInterval = null;

            girlElement.style.left = '50%';

            startButton.style.display = 'inline-block';
            restartButton.style.display = 'none';
        }

        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);

        resetGame(); // Initialize
    </script>

</body>
</html>